import json
import logging

from vtdb import dbexceptions

# Encapsulate a few key factors about an EMD keyspace. It is loaded
# out of zkocc.
class Keyspace:
  name = None
  db_types = None
  shard_count = None
  shard_max_keys = None # Sorted list of the max keys for each shard.

  # load this object from a SrvKeyspace object generated by vt
  def __init__(self, name, data):
    self.name = name
    self.db_types = data['TabletTypes']
    self.shard_count = len(data['Shards'])
    # if we have real values for shards and KeyRange.End, grab them
    if self.shard_count > 1 and data['Shards'][0]['KeyRange']['End'] != "":
      self.shard_max_keys = [shard['KeyRange']['End']
                             for shard in data['Shards']]

  def keyspace_id_to_shard_index(self, keyspace_id):
    if not self.shard_max_keys:
      raise ValueError('Keyspace is not range sharded', self.name)
    result = 0
    while result < self.shard_count-1 and keyspace_id >= self.shard_max_keys[result]:
      result += 1
    return result

# keyspace_path: /zk/<cell>/vt/ns/<keyspace>
def read_keyspace(zkocc_client, keyspace_path):
  try:
    data = zkocc_client.get(keyspace_path)['Data']
    if not data:
      raise dbexceptions.OperationalError('invalid keyspace', keyspace_path)
    return Keyspace(keyspace_name, json.loads(data))
  except Exception as e:
    raise dbexceptions.OperationalError('invalid keyspace', keyspace_path, e)
